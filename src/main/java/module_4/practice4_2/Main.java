/**
 Практика. Коллекции. List.
 Задание 1.
 Создание и заполнение ArrayList: Описание: Создайте ArrayList целых чисел, заполните его случайными числами и выведите содержимое на экран.
 Алгоритм выполнения:
 •	Создать ArrayList.
 •	Использовать цикл для добавления случайных чисел в ArrayList.
 •	Вывести содержимое ArrayList на экран.

 Задание 2.
 Удаление элементов из ArrayList:
 Описание: удалите из ArrayList все числа, которые больше заданного значения.
 Алгоритм выполнения:
 •	Создать ArrayList и заполнить его числами.
 •	Использовать цикл для перебора элементов и удаления чисел, которые больше заданного значения.

 Задание 3.
 Объединение двух ArrayList:
 Описание: объедините два ArrayList в один и выведите результат.
 Алгоритм выполнения:
 •	Создать два ArrayList.
 •	Добавить элементы в оба ArrayList.
 •	Создать третий ArrayList и добавить в него все элементы из первых двух.
 Вывести содержимое третьего ArrayList на экран.

 Задание 4.
 Поиск элемента в ArrayList: Описание: найдите индекс заданного элемента в ArrayList.
 Алгоритм выполнения:
 •	Создать ArrayList и добавить строки в него.
 •	Использовать метод indexOf() для поиска индекса заданного элемента.
 •	Вывести индекс элемента на экран.

 Задание 5.
 Обратный порядок элементов в LinkedList: Описание: создайте LinkedList строк и выведите элементы в обратном порядке.
 Алгоритм выполнения:
 •	Создать LinkedList и добавить строки в него.
 •	Использовать цикл для вывода элементов LinkedList в обратном порядке.
 •	Удаление повторяющихся элементов из ArrayList:

 Задание 6.
 Сравнение производительности ArrayList и LinkedList:
 Описание: сравните время доступа по индексу для больших коллекций ArrayList и LinkedList.
 Алгоритм выполнения:
 •	Создайте две коллекции, например, ArrayList и LinkedList, и добавьте в них большое количество элементов. Например, 1 миллион элементов.
 •	Замерить время доступа к элементу по индексу для ArrayList и LinkedList. Для замера производительности доступа по индексу в ArrayList и LinkedList в Java можно воспользоваться системным временем выполнения (System.currentTimeMillis() или System.nanoTime()).
 •	Для каждой коллекции измерьте время доступа к элементу по индексу. Для этого выберите случайный индекс в пределах размера коллекции и замерьте время, которое требуется для доступа к элементу по этому индексу.
 •	Для ArrayList это будет list.get(index), а для LinkedList - цикл для перебора элементов с использованием итератора или метода list.get(index).
 •	Для получения более точных результатов повторите замеры доступа к элементу по индексу несколько раз (например, 1000 итераций) и усредните полученные значения времени доступа.
 •	После завершения замеров сравните среднее время доступа к элементу по индексу для ArrayList и LinkedList.
 •	Выявите разницу в производительности доступа к элементам по индексу для обеих коллекций и сделайте выводы о том, какая коллекция работает быстрее в данном случае.
 Пример кода для замера производительности доступа к элементу по индексу в ArrayList:
 ArrayList<Integer> arrayList = new ArrayList<>();
 int size = 1000000;
 for (int i = 0; i < size; i++) {
 arrayList.add(i);
 }
 int index = 500000; // Пример индекса, к которому обращаемся
 long startTime = System.nanoTime();
 int element = arrayList.get(index);
 long endTime = System.nanoTime();
 long duration = endTime - startTime;
 System.out.println("Time taken to access element at index " + index + " in ArrayList: " + duration + " nanoseconds");
*/

package module_4.practice4_2;

public class Main {
  public static void main(String[] args) {
    Task1.execute();
    Task2.execute();
    Task3.execute();
    Task4.execute();
    Task5.execute();
    Task6.execute();
  }
}

/**
 Выполните:
javac *.java && java Main
 */
